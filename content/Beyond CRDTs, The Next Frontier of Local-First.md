---
title: "Beyond CRDTs, the next frontier of local-first"
---

#presentation

A major problem, and the one receiving the most attention, in collaborative & local-first software is figuring out how to merge concurrent edits between users. We're going to assume that this is completely solved and that the developer experience around it is great.

In this world,

- CRDTs can live alongside normal data
- Precise merge semantics is easy to define and user intent is easy to preserve by composing off the shelf CRDTs
- CRDTs can be easily queried over
- CRDTs can easily be paged out to disk and loaded to memory as needed

Things look bright. If we go off to try to build a local-first application in this world, however, we get stuck fast.

# The Next Frontier

A new frontier of problems show up:
- Auth
- Schema evolution
- Heterogenous devices
- Multi-tenancy
- Permissions & Sharing

Out of these 5 problems, we find that the first two are pretty easily solved by making some pragmatic choices.

- Force sync to go through a central server
- Disallow a client to sync if client_schema_version != server_schema_version

The other three seem impenetrable. What makes them interesting and alluring, however, is that they're all variations on the same problem.

# Three in One

**Heterogenous devices:**

> A single user has many devices on which they'll install the same local-first application. Each device has different compute and storage characteristics.

This is a problem since what we can store on a phone != what we can store on a laptop. The capacity of what a single user can store will differ based on which device they're using to interact with the app. We can't assume all data generated by the user on their laptop can ever be fully synced to their phone.

The problem then is knowing what subset of the user's data should be synced to a given device.

**Multi-tenancy:**

> Saving all data for all users in a single database on the backend. E.g., traditional application architectures on a multi-tenant DB like Postgres.

Multi-tenancy is implemented in client-server models to facilitate features around sharing. Data produced by one user might need to be visible to other users. The easiest way to handle that is to stick everything into a single database.

The problem this poses for local-first, however, is in understanding what data to sync to which users.

**Permissions & Sharing:**

> Giving users access to new pieces of data.

This is similar to multi-tenancy in that permissions would be used as the mechanism to partition tenants within a database. Thinking of it as permissions, however, brings to light the dynamic nature of the problem.

A new user may install a local-first app. At first, they only have access to their own data but eventually they're added to different roles or user groups. Now they suddenly have access to millions of rows of data produced by other users.

How do we detect a permission change has occurred and what things are newly visible? How do we know which of the newly visible items should be synced?

All of these problems are about having more data in one place than can fit, or be accessed, in another.

The ever-present `memory -> disk -> network` data tiering still exists, even in Local-First software.

How do we attack this problem?

# Developer Experience

All of this inevitably bubbles up into the developer experience. The developer needs to know whether a query is immediately resolved from in-memory data, is waiting on data from disk, is waiting on data from the network.

Waiting on data from the network...

Ignoring the problem and pretending all data is "always available"

All of these issues bubble up into the developer experience of writing local-first software. The tiers of data:

`memory -> disk -> network` clearly still exist, even in a local-first stack.

---

is the fact that a single user has many devices, each of which has different compute characteristics and each of which should be able to run 





Or maybe:
"Sorry, local-first isn't easier"

---

CRDTs (or some other convergence mechanism) is only the first frontier.

What follows:
1. Permissions
3. Bottomless replication due to size constraints
4. Moving out of memory and async vs sync browser quirkiness
5. Multi-tenant DBs
6. Query based sync
7. Perf? The "functional relational" is a separate concern from local-first...
8. Server authoritative?

What follows re-cast:
	- Bottomless replication (change devices examples)
	- Auth
	- Sharing (variation on multi-tenancy of many users in 1 db)
	- Better RX?
	- Local networking?
	- App delivery? (dweb tomorrow example)
	- Intent?
	- what is network delayed vs what is immediate? Is the immediate data really complete? Mixing consistency models
	- Local-first may not actually simplify development at all. It just looks simple at the outset.
	- The sync but not sync issue. UI -> Disk -> Network.

Some good thoughts in this vein are forming in [[row level security]], [[client defined query based sync]], [[incrementalism]], [[bloom filters for row level security]], [[inverted database]]