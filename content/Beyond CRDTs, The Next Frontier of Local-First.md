---
title: "Beyond CRDTs, the next frontier of local-first"
---

#presentation

A major problem, and the one receiving the most attention, in collaborative & local-first software is figuring out how to merge concurrent edits between users. We're going to assume that this is completely solved and that the developer experience around it is great.

In this world:

- CRDTs can live alongside, and be joined with, normal data
- Precise merge semantics is easy to define and user intent is easy to preserve by composing off the shelf CRDTs
- Locally stored CRDTs can be easily queried over and indexed through something like SQL
- CRDTs can easily be paged out to disk and loaded to memory as needed

Things look bright. If we go off to try to build a local-first application in this world, however, we get stuck fast.

# The Next Frontier

We get stuck on a new frontier of problems:
- Auth
- Schema evolution
- Heterogenous devices
- Multi-tenancy
- Permissions & Sharing

To understand the most pressing issues blocking development, we're going to be taking the mindset of a scrappy startup trying to ship a local-first app _today_. Given that, we'll make some simplifying architectural decisions and see which of the above problems still remain.

# Auth

The simplest way to handle auth today would be to force all access to data that exists off-device to go through a central service. The client can prove their identity to the server, the server ensures only authorized writes are synced to other clients.

Auth is a non-issue under this constraint.

## Schema Evolution

Allowing clients to make writes while offline does introduce some problems from a schema evolution perspective. We can render this problem a non-issue by:

1. Leveraging the fact that all changes must go through a central server
2. Disallowing sync between client and server while they have mismatched schema versions

Clients must upgrade to the current schema version (either via page refresh or installing an app update) to continue syncing their changes.

## Heterogenous Devices

This is our first _real_ problem. The issue here is that users of our app will have many different devices on which they'll install our app. Each device will have different storage and compute characteristics. All the data that can fit locally on the user's laptop likely will not fit on their phone or watch or whatever.

So we're faced with the problem of how to define a subset of the user's data to sync to a device.

How is this solved in traditional apps?

```ts
function Component() {
	const { isLoading, error, data } = useQuery('repoData', () =>
    fetch('https://api.github.com/repos/tannerlinsley/react-query').then(res =>
      res.json()
    )
  )
}
```


---

To make these problems tractable, we'll assume that the local-first apps are using a server to broker all communication between clients.

Given the use of a central server, auth becomes a non-issue.


---


## Schema Evolution

Schema Evolution is interesting but we can take 

Out of these 5 problems, we find that the first two are pretty easily solved by making some pragmatic choices.

- Force sync to go through a central server
- Disallow a client to sync if client_schema_version != server_schema_version

The other three seem impenetrable. What makes them interesting and alluring, however, is that they're all variations on the same problem.

# Three in One

**Heterogenous devices:**

> A single user has many devices on which they'll install the same local-first application. Each device has different compute and storage characteristics.

This is a problem since what we can store on a phone != what we can store on a laptop. The capacity of what a single user can store will differ based on which device they're using to interact with the app. We can't assume all data generated by the user on their laptop can ever be fully synced to their phone.

The problem then is knowing what subset of the user's data should be synced to a given device.

**Multi-tenancy:**

> Saving all data for all users in a single database on the backend. E.g., traditional application architectures on a multi-tenant DB like Postgres.

Multi-tenancy is implemented in client-server models to facilitate features around sharing. Data produced by one user might need to be visible to other users. The easiest way to handle that is to stick everything into a single database.

The problem this poses for local-first, however, is in understanding what data to sync to which users.

**Permissions & Sharing:**

> Giving users access to new pieces of data.

This is similar to multi-tenancy in that permissions would be used as the mechanism to partition tenants within a database. Thinking of it as permissions, however, brings to light the dynamic nature of the problem.

A new user may install a local-first app. At first, they only have access to their own data but eventually they're added to different roles or user groups. Now they suddenly have access to millions of rows of data produced by other users.

How do we detect a permission change has occurred and what things are newly visible? How do we know which of the newly visible items should be synced?

All of these problems are about having more data in one place than can fit, or be accessed, in another.

The ever-present `memory -> disk -> network` data tiering still exists, even in Local-First software.

How do we attack this problem?

^-- treat problems individually. heterog / bottomless is unqiue as it necessitates the network bound. Could create a new problem related to devx of getting data async.

# Developer Experience

All of this inevitably bubbles up into the developer experience. The developer needs to know whether a query is immediately resolved from in-memory data, is waiting on data from disk, is waiting on data from the network.

Waiting on data from the network...

Ignoring the problem and pretending all data is "always available"

All of these issues bubble up into the developer experience of writing local-first software. The tiers of data:

`memory -> disk -> network` clearly still exist, even in a local-first stack.

---

is the fact that a single user has many devices, each of which has different compute characteristics and each of which should be able to run 





Or maybe:
"Sorry, local-first isn't easier"

---

CRDTs (or some other convergence mechanism) is only the first frontier.

What follows:
1. Permissions
3. Bottomless replication due to size constraints
4. Moving out of memory and async vs sync browser quirkiness
5. Multi-tenant DBs
6. Query based sync
7. Perf? The "functional relational" is a separate concern from local-first...
8. Server authoritative?

What follows re-cast:
	- Bottomless replication (change devices examples)
	- Auth
	- Sharing (variation on multi-tenancy of many users in 1 db)
	- Better RX?
	- Local networking?
	- App delivery? (dweb tomorrow example)
	- Intent?
	- what is network delayed vs what is immediate? Is the immediate data really complete? Mixing consistency models
	- Local-first may not actually simplify development at all. It just looks simple at the outset.
	- The sync but not sync issue. UI -> Disk -> Network.

Some good thoughts in this vein are forming in [[row level security]], [[client defined query based sync]], [[incrementalism]], [[bloom filters for row level security]], [[inverted database]]